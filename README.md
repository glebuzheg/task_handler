## Мини-сервис обработки задач

### Как запустить

- **Требования**: Docker, Docker Compose, опционально `uv` для локальной разработки.
- **Запуск в Docker**:
    - В корне проекта выполните `docker-compose up --build`.
    - Документация `http://localhost:8000/swagger/`.
    - В контейнере зависимости устанавливаются через `uv` (`uv pip install --system -r requirements.txt`).
- **Локальный запуск с uv** (без Docker):
    - Перейдите в виртуальное окружение и установите `uv`, 'pip install uv'.
    - В корне проекта выполните `uv pip install -r requirements.txt`.
    - Создайте `.env` (см .env_example).
    - Примените миграции: `python manage.py migrate`.
    - Запустите сервер: `python manage.py runserver`.
- **Основные эндпоинты**:
    - **Создание задачи**: `POST /api/v1/tasks/` с телом `{ "title": "Process report" }`.
    - **Список задач**: `GET /api/v1/tasks/?status=new` (фильтрация по статусу, пагинация).
    - **Получение задачи**: `GET /api/v1/tasks/{id}/`.

### Как работает фоновая обработка

- При создании задачи через `POST /tasks/`:
    - Создаётся запись с полями: `title` из запроса, `status="new"`, `result=null`.
    - В очередь Celery отправляется задача `process_task` с `task_id`.
- Воркер Celery (`process_task`):
    - В транзакции переводит статус задачи в `processing` через `TaskService.start_processing`, блокируя запись
      `select_for_update`, чтобы избежать гонок.
    - Имитирует работу, делая `sleep(3)`.
    - Во второй транзакции через `TaskService.complete_processing` рассчитывает финальный статус и результат:
        - чётная длина `title` → `status="done"`, `result="success"`;
        - нечётная длина → `status="failed"`, `result="error"`.

### Что бы улучшил в production

- **Надёжность и мониторинг**: добавить конфигурацию для health-check'ов, метрик (Prometheus), логирования в
  централизованное хранилище и алертов по ошибкам Celery.
- **Масштабирование**: настроить autoscaling воркеров, использовать отдельные очереди для разных типов задач.
- **Безопасность**: хранить секреты (SECRET_KEY, пароли БД, брокеров) в защищённом хранилище, включить валидацию входных
  данных на уровне схем, ограничить `ALLOWED_HOSTS` и настроить HTTPS.
- **Качество кода**: добавить static typing (mypy), линтеры (flake8/ruff), более подробные тесты (включая интеграционные
  для Celery и БД) и CI-пайплайн для прогонки тестов и линтеров при каждом изменении. Также можно развить `TaskService`
  в полноценный слой доменных сервисов и применить паттерны `State`/`Strategy` для более сложных сценариев смены
  статуса.
